\documentclass[a4paper]{report}
\usepackage{float}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\graphicspath{ {./graph/} }
\usepackage{lmodern}
\usepackage{kpfonts}
\usepackage{titlesec}
\usepackage{listings}
\usepackage{color}
\usepackage{fontspec}
\usepackage{multirow}
\usepackage{float}
\usepackage{array}
\usepackage{afterpage}

\usepackage[font={small}, labelfont={bf}, format=hang, skip=8pt]{caption}


\setmainfont{Helvetica} % Set the main font to Helvetica
\setmonofont{Noto Sans Mono} % Set the monofont to Andale Mono

% Imposta lo spacing tra il titolo del paragrafo e il testo successivo
\usepackage[left=3.6cm,right=3.6cm,top=2.5cm,bottom=2.25cm]{geometry}

\definecolor{grigio}{rgb}{0.95,0.95,0.95}
\definecolor{mygrey}{rgb}{0.8,0.8,0.8}
\definecolor{mygreen}{rgb}{0.2,0.4,0.2}

\lstset{
  firstnumber=1,                % start line enumeration with line 1000
  language=Verilog,
  numbers=left,
  stepnumber=1,
  numbersep=4pt,
  numberstyle=\tiny\color{mygrey}, % the style that is used for the line-numbers
  backgroundcolor=\color{grigio},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=3,
  captionpos=b,
  breaklines=true,
  breakatwhitespace=true,
  escapeinside={\%*}{*)},
  basicstyle=\ttfamily\fontsize{8pt}{10pt}\selectfont, % Set the basic code style to a smaller font
  keywordstyle=\bfseries,
  commentstyle=\color{mygreen}
}

\titleformat{\chapter}[display]
{\normalfont\huge\bfseries\fontsize{14pt}{10pt}\selectfont}{\chaptertitlename\ \thechapter}{18pt}{\Huge}

\author{Tommi Bimbato VR500751, Antonio Iovine VR504083}
\title{Elaborato Assembly \\ \normalsize Corso di Architettura degli Elaboratori A.A. 2023/2024 \\ Prof.\ Franco Fummi, Prof.\ Michele Lora}

\begin{document}

\begin{titlepage}
  \maketitle
\end{titlepage}

\thispagestyle{empty} % Remove header from title page

\tableofcontents % Add table of contents

\begin{abstract}
  L'obiettivo del progetto è sviluppare un software per la pianificazione delle attività di un sistema produttivo. La produzione è organizzata in slot temporali uniformi, durante i quali un solo prodotto può essere in fase di lavorazione. Il software consentirà di ottimizzare la pianificazione delle attività secondo due algoritmi di pianificazioni differenti. L'intero software è stato sviluppato in linguaggio Assembly (Sintassi AT\&T) e testato su un insieme di dati di prova allegati a questa documentazione.
\end{abstract}

\chapter{Introduzione}
\section{Approccio progettuale}
L'elaborato è stato condotto seguendo un approccio metodologico strutturato. Inizialmente, è stata eseguita un'analisi dettagliata per identificare i requisiti e le funzionalità principali del software. Questo processo ha consentito una comprensione completa del contesto operativo e degli obiettivi da raggiungere.

Successivamente, è stata sviluppata una bozza del software utilizzando il linguaggio di programmazione C. Questo ha permesso la traduzione dei requisiti in una struttura logica e l'identificazione dell'architettura generale del software.

Parallelamente, sono stati definiti gli spazi di memoria necessari per la memorizzazione dei dati durante l'esecuzione del programma. Ciò ha garantito un utilizzo efficiente delle risorse disponibili.

Infine, sono stati eseguiti test approfonditi per verificare il corretto funzionamento del programma e identificare eventuali aree di miglioramento. L'iterazione su questo processo ha portato a modifiche e ottimizzazioni fino al raggiungimento di un livello soddisfacente di prestazioni e funzionalità.

\section{Analisi delle specifiche}
La produzione è organizzata in slot temporali uniformi, durante i quali un solo prodotto può essere in fase di lavorazione. Il programma analizza una serie di prodotti, ognuno caratterizzato da un identificativo, una durata, una scadenza e una priorità secondo le specifiche seguenti:
\begin{itemize}
  \item Identificativo: un codice da 1 a 127;
  \item Durata: il numero di slot temporali per il completamento (da 1 a 10);
  \item Scadenza: il limite massimo di tempo entro cui il prodotto deve essere completato (da 1 a 100);
  \item Priorità: un valore da 1 a 5, che indica sia la priorità che la penalità per il ritardo sulla scadenza\footnote{Il valore 5 indica la priorità più alta.}.
\end{itemize}
Al termine della pianificazione, il programma calcolerà la penale dovuta agli eventuali ritardi di produzione.

\subsection{Input}
L'utente invoca il programma "pianificatore" e fornisce due file come parametri da linea di comando, il primo viene considerato input, mentre il secondo viene utilizzato per salvare i risultati della pianificazione. Ad esempio:

\begin{verbatim}
pianificatore Ordini.txt Pianificazione.txt
\end{verbatim}

In questo caso, il programma caricherà gli ordini dal file \texttt{Ordini.txt} e salverà le statistiche stampate a video nel file \texttt{Pianificazione.txt}.

Se l'utente fornisce solo un parametro, il salvataggio della pianificazione su file verrà ignorato.

Il file degli ordini dovrà avere un prodotto per riga, con tutti i parametri separati da virgola. Ad esempio, se l'ordine fosse:
\begin{verbatim}
ID: 4; Durata: 10; Scadenza: 12; Priorità: 4;
\end{verbatim}
Il file dovrà contenere la seguente riga:
\begin{verbatim}
4,10,12,4
\end{verbatim}

\subsection{Algoritmi di pianificazione}
Una volta letto il file, il programma visualizzerà il menu principale, permettendo all'utente di selezionare l'algoritmo di pianificazione desiderato. Le opzioni disponibili sono:

\begin{enumerate}
  \item Earliest Deadline First (EDF): Si pianificano per primi i prodotti con scadenza più vicina. In caso di parità nella scadenza, si considera la priorità più alta.
  \item Highest Priority First (HPF): Si pianificano per primi i prodotti con la priorità più alta. In caso di parità di priorità, si considera la scadenza più vicina.
\end{enumerate}

L'utente può selezionare uno dei due algoritmi per la pianificazione delle attività del sistema produttivo.

\section{Sviluppo}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{scheme.png}
  \caption{Schema del funzionamento del software.}
  \label{fig:schema}
\end{figure}

\subsection{Acquisizione e struttura dati}
Il software acquisisce l'intero contenuto del file di input e lo memorizza in una variabile nel buffer, parallelamente ne calcola la lunghezza (numero di righe) per allocare la memoria necessaria per la struttura dati vera e propria. Successivamente, il programma procede a leggere il contenuto del buffer, converte le informazioni dal formato ASCII al formato numerico e le memorizza in un array di struct. La peculiarità di questa struttura dati è che lo spazio occupato da un prodotto (ID, durata, scadenza e priorità) è di 4 byte totali, pari alla dimensione di un registro interno del processore considerato per l'applicazione del software.

\subsection{Ordinamento dei prodotti}
Acquisita la struttura dati, il programma acquisisce la scelta dell'algoritmo di pianificazione da parte dell'utente e procede con l'ordinamento dei prodotti in base alla scelta effettuata.
Il sorting è gestito da una variabile che definisce la priorità di ordinamento (HPF o EDF) che viene passata alla funzione di ordinamento come parametro. La funzione di ordinamento, a sua volta, si occupa di confrontare i prodotti in base alla priorità scelta e di riordinarli in base a tale criterio nella struttura dati stessa.

Per l'effettivo ordinamento dei prodotti, il software utilizza un algoritmo di sorting di tipo "insertion sort" che si è dimostrato il più efficiente per la dimensione dei dati in ingresso.
Il secondo ordinamento, ovvero quello che compara il parametro "scadenza" in caso di parità di priorità o "priorità in caso di pari scadenza, è gestito da una funzione basata su algoritmo di bubble sort.

\subsection{Output}
Nel caso venisse specificato un file di output, il software stamperà su di esso i risultati della pianificazione secondo il seguente schema:
\begin{verbatim}
<Algoritmo di pianificazione scelto>:
<ID del prodotto>:<Inizio produzione>
[...]
Conclusione:<timeslot termine produzione>
Penalty:<penalità totale>
\end{verbatim}

\subsection{Penalità}
Se un prodotto non viene completato entro la scadenza, il programma calcola la penalità in base alla priorità del prodotto e alla quantità di slot temporali di ritardo. La penalità è calcolata come segue:

\[
\text{Penalità} = \text{Priorità} \times \text{Ritardo}
\]


\section{Codice}


\subsection{File sorgente}

\subsubitem{Il programma è composto dai seguenti file sorgente in linguaggio assembly:}
\begin{itemize}
  \item \texttt{btoa.s}: byte to ASCII, funzione per la conversione di un byte in ASCII;
  \item \texttt{BufferToArray.s}: funzione per la conversione del buffer di lettura in un array di struct;
  \item \texttt{InsertionSort.s}: funzione per il primo ordinamento dei prodotti;
  \item \texttt{EqualSort.s}: funzione per il secondo ordinamento dei prodotti;
  \item \texttt{menu.s}: file contenente la funzione per il menù.
  \item \texttt{main.s}: funzione principale del programma.
\end{itemize}

A completare la struttura del programma, sono presenti i seguenti file di supporto:
\begin{itemize}
  \item \texttt{Makefile}: file per la compilazione del programma;
  \item \texttt{EDF.txt}: file di input con penalità uguale a zero con EDF e maggiore di zero con HPF;
  \item \texttt{HPF.txt}: file di input con penalità uguale a zero con HPF e maggiore di zero con EDF;
  \item \texttt{Both.txt}: file di input con penalità uguale a zero con entrambi gli algoritmi;
  \item \texttt{None.txt}: file di input con penalità maggiore di zero con entrambi gli algoritmi.
\end{itemize}

\subsection{Analisi di alcune parti fondamentali del codice}

\begin{lstlisting}[firstnumber=34]
  Codice in ASM!!!
  int main pippo VOID !!!
  ; Gibberish Assembly Code
  mov eax, 0
  add ebx, eax
  sub ecx, ebx
  
  mul edx, ecx
  div  
  nop
  cmp eax, ebx
  jne label
\end{lstlisting}

\begin{lstlisting}[firstnumber=343]

ul edx, ecx
  div esi, edx
  push eax
  pop ebx
  inc ecx
  dec edx
  jmp label
  label:l edx, ecx
  div esi, edx
  push eax
  pop ebx
  inc ecx
  dec edx
  jmp label
  label:l edx, ecx
  div esi, edx
  push eax
  pop ebx
  inc ecx
  dec edx
  jmp label
  label:l edx, ecx
  div esi, edx
  push eax
  pop ebx
  inc ecx
  dec edx
  jmp label
  label:l edx, ecx
  div esi, edx
  push eax
  pop ebx
  inc ecx
  dec edx
  jmp label
  label:l edx, ecx
  div esi, edx
  push eax
  pop ebx
  inc ecx
  dec edx
  jmp label
  label:
  nop
  cmp eax, ebx
  jne label
  sub ecx, ebx
  mul edx, ecx
  div esi, edx
!

  sub ecx, ebx

  \end{lstlisting}


\end{document}
